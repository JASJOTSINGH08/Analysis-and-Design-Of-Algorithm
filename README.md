- Selection Sort, Graphical Analysis : This code implements the Selection Sort algorithm to sort arrays of varying sizes, measuring execution time for each size. The data is then visualized through graphical analysis, showing how execution time scales with input size.
- Selection Sort, n^2 Elements : The code sorts arrays with sizes proportional to n^2 using Selection Sort. It measures execution time for each size and presents the data graphically, illustrating the algorithm's performance as input size increases quadratically.
- Selection Sort, log n Elements : This code adapts Selection Sort to handle arrays whose sizes grow logarithmically with the input size. It measures execution time for each adjusted size and displays the results graphically, showing the algorithm's behavior with logarithmically increasing input sizes.
- Selection Sort, 2^n Elements : The code sorts arrays with sizes exponentially increasing as powers of 2 using Selection Sort. It records execution time for each size and visualizes the data graphically, demonstrating how execution time changes with exponentially growing input sizes.
- Selection Sort, n Factorial Elements : This code applies Selection Sort to arrays whose sizes are factorial, incrementing from 1 to 8. It measures execution time for each size and presents the data graphically, showing the algorithm's performance with factorial input sizes.
- Linear Search: Iterates through array to find target element. Time complexity: O(n).
- Binary Search: Efficiently searches sorted array using divide-and-conquer. Time complexity: O(log n).
- Exponentiation by Squaring: Calculates large powers using divide-and-conquer method. Time complexity: O(log n).
- Power of Integer Elements: Computes power of integers using recursion. Time complexity: O(log n).
- Partition Sorting, Pivot : This C++ code implements partition sorting using the pivot element. It efficiently partitions an array into two segments, placing smaller elements to the left and larger elements to the right of the pivot. The time complexity is O(n), making it suitable for sorting large datasets.
- Magic Square, Random N : The provided C++ code generates a magic square of order n using the Siu Lun algorithm. It efficiently creates a magic square for any random n element input, recording the execution time for each step. The time complexity is O(n^2), suitable for producing magic squares of varying sizes.
- Merge Sort, n Elements : This C++ code implements the Merge Sort algorithm for sorting arrays of various sizes. It measures the execution time for different input sizes and records it in a CSV file. With a time complexity of O(nlogn), it efficiently sorts arrays of large sizes.
- Quick Select, kth Smallest Element : The provided C++ code efficiently finds the k-th smallest element in an array using the Quick Select algorithm. It partitions the array around a pivot element and adjusts the search range based on the pivot's position relative to k. With an average time complexity of O(n), it's suitable for finding specific elements in large arrays.
- Activity Selection : This C++ code implements the Activity Selection problem using a greedy approach. It sorts activities by their finish times and selects compatible activities iteratively. The time complexity is O(nlogn) for sorting and O(n) for selecting activities, making it efficient for scheduling tasks.
- Dijkstra's Shortest Path : The provided C++ code implements Dijkstra's algorithm to find the shortest paths from a given source vertex in a weighted graph. It utilizes a priority queue (min heap) to efficiently select vertices with the shortest tentative distances. The time complexity is O((V+E)logV), where V is the number of vertices and E is the number of edges.
- Prim's Minimum Spanning Tree : This C++ code demonstrates Prim's algorithm for finding the Minimum Spanning Tree (MST) of a weighted graph. It iteratively selects the minimum weight edge and adds it to the MST until all vertices are included. The time complexity is O(V^2) with an adjacency matrix representation and O(ElogV) with a priority queue.
- Minimum Cost Path : The C++ code uses dynamic programming to find the minimum cost path in a graph. It calculates the minimum cost to reach each vertex from the last vertex and reconstructs the optimal path. The time complexity is O(n_v^2), where n_v is the number of vertices, making it efficient for small graphs.
- Min Cost Path (Dynamic Programming) : Initializes arrays to store cumulative costs and path choices, calculates costs for reaching subsequent states using dynamic programming, and stores minimum cost path length and path choices. In the main function, it initializes system parameters and calls the function to compute the minimum cost path.
- Max & Min Elements (Divide & Conquer) : Utilizes a recursive divide-and-conquer approach to find the maximum and minimum elements in an array. It recursively divides the array into smaller subarrays until the base case, where it computes the minimum and maximum elements.
- Fractional Knapsack (Greedy) : Sorts items based on value-to-weight ratio, then iteratively selects items greedily, adding them to the knapsack until its capacity is reached. If an item's weight exceeds the remaining capacity, a fraction of it is added to maximize total value.
- Knapsack (Weight Approach) : Sorts items by weight, then iteratively selects items based on their weights, adding them to the knapsack until its capacity is reached. If an item's weight exceeds the remaining capacity, a fractional part is added to fill the knapsack optimally.
- Knapsack (Profit Approach) : Sorts items by value, then iteratively selects items based on their values, adding them to the knapsack until its capacity is reached. If an item's weight exceeds the remaining capacity, a fractional part is added to maximize total value.
- Assembly Line Scheduling: C++ code implements the algorithm for assembly line scheduling using dynamic programming, with initialization, dynamic programming steps, and output calculation. It then computes and outputs the minimum time to exit the assembly lines.
- Print All Sequences : C++ code recursively generates all possible sequences of characters in a given string using a backtracking approach, printing each sequence.
- Heap Sort : C++ code implements the heap sort algorithm, including functions for heapifying, sorting, and printing the array. It sorts an array in ascending order using the heap data structure.
- Strassen’s Matrix Multiplication: C++ code implements Strassen’s algorithm for matrix multiplication recursively, dividing matrices into submatrices, computing intermediate matrices, and merging the results.
- Horner’s Rule : C++ code evaluates a polynomial using Horner’s rule, recording the time complexity of each step and outputting the result. Python code plots the time complexity data for visualization.
Truth Table Permutations : C++ code generates all permutations of truth values for a given number of variables and records the time taken for each permutation. Python code reads and plots the recorded time complexity data for visualization.
Tower of Hanoi: Recursively solves Tower of Hanoi. The C++ code defines a function towerOfHanoi() which takes parameters for the number of disks, source, auxiliary, and destination rods, and an ofstream reference for writing time complexity data. It recursively moves disks between rods, recording the time taken for each move. The Python code reads the recorded data and plots the time complexity against the number of disks.
